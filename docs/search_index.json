[
["index.html", "Using R &amp; Neo4J Chapter 1 About 1.1 {neo4r}", " Using R &amp; Neo4J Colin Fay 2019-02-14 Chapter 1 About This book is a user companion for using Neo4J and R together with the {neo4r} package. 1.1 {neo4r} The goal of {neo4r} is to provide a modern and flexible Neo4J driver for R. It’s modern in the sense that the results are returned as tibbles whenever possible, it relies on modern tools, and it is designed to work with pipes. Our goal is to provide a driver that can be easily integrated in a data analysis workflow, especially by providing an API working smoothly with other data analysis ({dplyr} or {purrr}) and graph packages ({igraph}, {ggraph}, {visNetwork}…). It’s flexible in the sense that it is rather unopinionated regarding the way it returns the results, by trying to stay as close as possible to the way Neo4J returns data. That way, you have the control over the way you will compute the results. At the same time, the result is not too complex, so that the “heavy lifting” of data wrangling is not left to the user. The connexion object is also an easy to control R6 method, allowing you to update and query information from the API. Sending data for this book (the movies dataset is also loaded on the server): library(neo4r) con &lt;- neo4j_api$new( url = &quot;http://localhost:7474&quot;, user = &quot;neo4j&quot;, password = &quot;neo4j&quot; ) read_cypher(&quot;data-raw/create.cypher&quot;) ## # A tibble: 5 x 1 ## cypher ## &lt;chr&gt; ## 1 CREATE CONSTRAINT ON (b:Band) ASSERT b.name IS UNIQUE; ## 2 CREATE CONSTRAINT ON (c:City) ASSERT c.name IS UNIQUE; ## 3 CREATE CONSTRAINT ON (r:record) ASSERT r.name IS UNIQUE; ## 4 CREATE (ancient:Band {name: &#39;Ancient&#39;, formed: 1992}), (acturus:Band {na… ## 5 &quot;&quot; send_cypher(&quot;data-raw/create.cypher&quot;, con) ## No data returned. ## No data returned. ## No data returned. ## [[1]] ## # A tibble: 12 x 2 ## type value ## &lt;chr&gt; &lt;dbl&gt; ## 1 contains_updates 0 ## 2 nodes_created 0 ## 3 nodes_deleted 0 ## 4 properties_set 0 ## 5 relationships_created 0 ## 6 relationship_deleted 0 ## 7 labels_added 0 ## 8 labels_removed 0 ## 9 indexes_added 0 ## 10 indexes_removed 0 ## 11 constraints_added 0 ## 12 constraints_removed 0 ## ## [[2]] ## # A tibble: 12 x 2 ## type value ## &lt;chr&gt; &lt;dbl&gt; ## 1 contains_updates 0 ## 2 nodes_created 0 ## 3 nodes_deleted 0 ## 4 properties_set 0 ## 5 relationships_created 0 ## 6 relationship_deleted 0 ## 7 labels_added 0 ## 8 labels_removed 0 ## 9 indexes_added 0 ## 10 indexes_removed 0 ## 11 constraints_added 0 ## 12 constraints_removed 0 ## ## [[3]] ## # A tibble: 12 x 2 ## type value ## &lt;chr&gt; &lt;dbl&gt; ## 1 contains_updates 0 ## 2 nodes_created 0 ## 3 nodes_deleted 0 ## 4 properties_set 0 ## 5 relationships_created 0 ## 6 relationship_deleted 0 ## 7 labels_added 0 ## 8 labels_removed 0 ## 9 indexes_added 0 ## 10 indexes_removed 0 ## 11 constraints_added 0 ## 12 constraints_removed 0 ## ## [[4]] ## [[4]]$error_code ## [1] &quot;Neo.ClientError.Schema.ConstraintValidationFailed&quot; ## ## [[4]]$error_message ## [1] &quot;Node(16018) already exists with label `Band` and property `name` = &#39;Ancient&#39;&quot; ## ## ## [[5]] ## [[5]]$error_code ## [1] &quot;Neo.ClientError.Statement.SyntaxError&quot; ## ## [[5]]$error_message ## [1] &quot;Unexpected end of input: expected whitespace, CYPHER options, EXPLAIN, PROFILE or Query (line 1, column 1 (offset: 0))\\n\\&quot;\\&quot;\\n ^&quot; See the cypher query at https://github.com/neo4j-rstats/user-guide/blob/master/data-raw/create.cypher "],
["intro.html", "Chapter 2 Introduction 2.1 Installation", " Chapter 2 Introduction 2.1 Installation 2.1.1 Dev version from GitHub # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;neo4j-rstats/neo4r&quot;) "],
["connect.html", "Chapter 3 Connection 3.1 HTTP connection 3.2 Get informations about the connection :", " Chapter 3 Connection 3.1 HTTP connection You can start a new connection to your server with the neo4j_api object. You’ll need to call neo4j_api$new, with the url (with port specified if any), your user name, and your password. library(neo4r) con &lt;- neo4j_api$new( url = &quot;http://localhost:7474&quot;, user = &quot;neo4j&quot;, password = &quot;neo4j&quot; ) If you don’t want your password to be included in the script, you can use the rstudioapi::askForPassword() function, which will open a little widget asking to interactively enter your password. con &lt;- neo4j_api$new( url = &quot;http://localhost:7474&quot;, user = &quot;neo4j&quot;, password = rstudioapi::askForPassword() ) You can then check if you can access to the server by pinging it: con$ping() ## [1] 200 Which should return 200 if the connexion succeeded. 3.2 Get informations about the connection : You’ll then be able to get information about the server with: # Get Neo4J Version con$get_version() ## [1] &quot;3.4.5&quot; # List constaints (if any) con$get_constraints() ## label type property_keys ## 1: artist UNIQUENESS name ## 2: Maintainer UNIQUENESS name ## 3: Band UNIQUENESS name ## 4: City UNIQUENESS name ## 5: record UNIQUENESS name ## 6: Package UNIQUENESS name ## 7: Author UNIQUENESS name # Get a vector of labels (if any) con$get_labels() ## # A tibble: 9 x 1 ## labels ## &lt;chr&gt; ## 1 record ## 2 Band ## 3 Author ## 4 artist ## 5 Maintainer ## 6 Package ## 7 Person ## 8 City ## 9 Movie # Get a vector of relationships (if any) con$get_relationships() ## # A tibble: 9 x 1 ## labels ## &lt;chr&gt; ## 1 PLAYED_IN ## 2 IS_FROM ## 3 WAS_RECORDED ## 4 ACTED_IN ## 5 DIRECTED ## 6 PRODUCED ## 7 WROTE ## 8 FOLLOWS ## 9 REVIEWED # Get schema con$get_schema() ## label property_keys ## 1: Band name ## 2: Author name ## 3: artist name ## 4: City name ## 5: Maintainer name ## 6: Package name ## 7: record name "],
["retrieve.html", "Chapter 4 Retrieve data from the API 4.1 “rows” format 4.2 Parsing results", " Chapter 4 Retrieve data from the API The API can be called either from the connection objet, or with the call_neo4j() function. The call_neo4j() function takes several arguments : query : the cypher query con : the connexion object type : “rows” or “graph”: wether to return the results as a list of results in tibble, or as a graph object (with $nodes and $relationships) output : the output format (R or json) include_stats : whether or not to include the stats about the call meta : wether or not to include the meta arguments of the nodes when calling with “rows” 4.1 “rows” format The user chooses wether or not to return a list of tibbles when calling the API. You get as many objects as specified in the RETURN cypher statement. library(magrittr) &#39;MATCH (r:record) -[:WAS_RECORDED] -&gt; (b:Band) where b.formed = 1991 RETURN *;&#39; %&gt;% call_neo4j(con) ## $b ## # A tibble: 14 x 2 ## name formed ## &lt;chr&gt; &lt;int&gt; ## 1 Burzum 1991 ## 2 Burzum 1991 ## 3 Burzum 1991 ## 4 Burzum 1991 ## 5 Burzum 1991 ## 6 Burzum 1991 ## 7 Burzum 1991 ## 8 Enslaved 1991 ## 9 Enslaved 1991 ## 10 Enslaved 1991 ## 11 Enslaved 1991 ## 12 Immortal 1991 ## 13 Immortal 1991 ## 14 Immortal 1991 ## ## $r ## # A tibble: 14 x 2 ## release name ## &lt;int&gt; &lt;chr&gt; ## 1 1993 Filosofem ## 2 1992 Hvis lyset tar oss ## 3 1992 Aske ## 4 1992 Det som engang var ## 5 1992 Burzum ## 6 1991 Demo II ## 7 1991 Demo I ## 8 1992 Hordanes Land ## 9 1993 Vikingligr Veldi ## 10 1991 Nema ## 11 1992 Yggdrasill ## 12 1992 Diabolical Fullmoon Mysticism ## 13 1993 Pure Holocaust ## 14 1991 Immortal ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;neo&quot; &quot;list&quot; By default, results are returned as an R list of tibbles. We think this is the more “truthful” way to implement the outputs regarding Neo4J calls. For example, when you want to return two nodes types, you’ll get two results, in the form of two tibbles (what we’ve seen just before) - the result is a two elements list with each element being labelled the way it has been specified in the Cypher query. Results can also be returned in JSON: &#39;MATCH (r:record) -[:WAS_RECORDED] -&gt; (b:Band) where b.formed = 1991 RETURN *;&#39; %&gt;% call_neo4j(con, output = &quot;json&quot;) ## [ ## [ ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1993], ## &quot;name&quot;: [&quot;Filosofem&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16020], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16058], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Hvis lyset tar oss&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16020], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16053], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Aske&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16020], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16051], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Det som engang var&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16020], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16045], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Burzum&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16020], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16044], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1991], ## &quot;name&quot;: [&quot;Demo II&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16020], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16042], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1991], ## &quot;name&quot;: [&quot;Demo I&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16020], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16039], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Enslaved&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Hordanes Land&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16024], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16055], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Enslaved&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1993], ## &quot;name&quot;: [&quot;Vikingligr Veldi&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16024], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16060], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Enslaved&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1991], ## &quot;name&quot;: [&quot;Nema&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16024], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16043], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Enslaved&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Yggdrasill&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16024], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16049], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Immortal&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Diabolical Fullmoon Mysticism&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16027], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16046], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Immortal&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1993], ## &quot;name&quot;: [&quot;Pure Holocaust&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16027], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16066], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Immortal&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1991], ## &quot;name&quot;: [&quot;Immortal&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [16027], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [16041], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## } ## ] ## ] If you turn the type argument to &quot;graph&quot;, you’ll get a graph result: &#39;MATCH p=()-[r:WAS_RECORDED]-&gt;() RETURN p LIMIT 5&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) ## $nodes ## # A tibble: 6 x 3 ## id label properties ## &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 16020 &lt;chr [1]&gt; &lt;list [2]&gt; ## 2 16058 &lt;chr [1]&gt; &lt;list [2]&gt; ## 3 16053 &lt;chr [1]&gt; &lt;list [2]&gt; ## 4 16051 &lt;chr [1]&gt; &lt;list [2]&gt; ## 5 16045 &lt;chr [1]&gt; &lt;list [2]&gt; ## 6 16044 &lt;chr [1]&gt; &lt;list [2]&gt; ## ## $relationships ## # A tibble: 5 x 5 ## id type startNode endNode properties ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; ## 1 23757 WAS_RECORDED 16058 16020 &lt;list [0]&gt; ## 2 23756 WAS_RECORDED 16053 16020 &lt;list [0]&gt; ## 3 23755 WAS_RECORDED 16051 16020 &lt;list [0]&gt; ## 4 23754 WAS_RECORDED 16045 16020 &lt;list [0]&gt; ## 5 23753 WAS_RECORDED 16044 16020 &lt;list [0]&gt; ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; The result is returned as one node or relationship by row. Due to the specific data format of Neo4J, there can be more than one label and property by node and relationship. That’s why the results are returned, by design, as a list-dataframe. 4.2 Parsing results We have designed several functions to unnest the output : unnest_nodes(), that can unnest a node dataframe : res &lt;- &#39;MATCH p=()-[r:WAS_RECORDED]-&gt;() RETURN p LIMIT 5;&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) unnest_nodes(res$nodes) ## # A tibble: 6 x 5 ## id value name formed release ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 16020 Band Burzum 1991 NA ## 2 16058 record Filosofem NA 1993 ## 3 16053 record Hvis lyset tar oss NA 1992 ## 4 16051 record Aske NA 1992 ## 5 16045 record Det som engang var NA 1992 ## 6 16044 record Burzum NA 1992 Note that this function will return NA for the properties that aren’t in a node. For example here, we have no ‘formed’ information for the record nodes . On the long run, and this is not {neo4r} specific but Neo4J related, a good practice is to have a “name” propertie on each node, so this column will be full here. Also, it is possible to unnest either the properties or the labels : res$nodes %&gt;% unnest_nodes(what = &quot;properties&quot;) ## # A tibble: 6 x 5 ## id label name formed release ## &lt;chr&gt; &lt;list&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 16020 &lt;chr [1]&gt; Burzum 1991 NA ## 2 16058 &lt;chr [1]&gt; Filosofem NA 1993 ## 3 16053 &lt;chr [1]&gt; Hvis lyset tar oss NA 1992 ## 4 16051 &lt;chr [1]&gt; Aske NA 1992 ## 5 16045 &lt;chr [1]&gt; Det som engang var NA 1992 ## 6 16044 &lt;chr [1]&gt; Burzum NA 1992 res$nodes %&gt;% unnest_nodes(what = &quot;label&quot;) ## # A tibble: 6 x 3 ## id properties value ## &lt;chr&gt; &lt;list&gt; &lt;chr&gt; ## 1 16020 &lt;list [2]&gt; Band ## 2 16058 &lt;list [2]&gt; record ## 3 16053 &lt;list [2]&gt; record ## 4 16051 &lt;list [2]&gt; record ## 5 16045 &lt;list [2]&gt; record ## 6 16044 &lt;list [2]&gt; record unnest_relationships() There is only one nested column in the relationship table, thus the function is quite straightforward : unnest_relationships(res$relationships) ## # A tibble: 5 x 5 ## id type startNode endNode value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 23757 WAS_RECORDED 16058 16020 NA ## 2 23756 WAS_RECORDED 16053 16020 NA ## 3 23755 WAS_RECORDED 16051 16020 NA ## 4 23754 WAS_RECORDED 16045 16020 NA ## 5 23753 WAS_RECORDED 16044 16020 NA unnest_graph() This function takes a graph results, and does unnest_nodes and unnest_relationships. unnest_graph(res) ## $nodes ## # A tibble: 6 x 5 ## id value name formed release ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 16020 Band Burzum 1991 NA ## 2 16058 record Filosofem NA 1993 ## 3 16053 record Hvis lyset tar oss NA 1992 ## 4 16051 record Aske NA 1992 ## 5 16045 record Det som engang var NA 1992 ## 6 16044 record Burzum NA 1992 ## ## $relationships ## # A tibble: 5 x 5 ## id type startNode endNode value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 23757 WAS_RECORDED 16058 16020 NA ## 2 23756 WAS_RECORDED 16053 16020 NA ## 3 23755 WAS_RECORDED 16051 16020 NA ## 4 23754 WAS_RECORDED 16045 16020 NA ## 5 23753 WAS_RECORDED 16044 16020 NA ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; 4.2.1 Extraction There are two convenient functions to extract nodes and relationships: &#39;MATCH p=()-[r:WAS_RECORDED]-&gt;() RETURN p LIMIT 5;&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) %&gt;% extract_nodes() ## # A tibble: 6 x 3 ## id label properties ## &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 16020 &lt;chr [1]&gt; &lt;list [2]&gt; ## 2 16058 &lt;chr [1]&gt; &lt;list [2]&gt; ## 3 16053 &lt;chr [1]&gt; &lt;list [2]&gt; ## 4 16051 &lt;chr [1]&gt; &lt;list [2]&gt; ## 5 16045 &lt;chr [1]&gt; &lt;list [2]&gt; ## 6 16044 &lt;chr [1]&gt; &lt;list [2]&gt; "],
["send.html", "Chapter 5 Sending data to the API 5.1 Convert for common graph packages", " Chapter 5 Sending data to the API 5.0.1 Reading and sending a cypher file : read_cypher reads a cypher file and returns a tibble of all the calls read_cypher(&quot;data-raw/create.cypher&quot;) ## # A tibble: 5 x 1 ## cypher ## &lt;chr&gt; ## 1 CREATE CONSTRAINT ON (b:Band) ASSERT b.name IS UNIQUE; ## 2 CREATE CONSTRAINT ON (c:City) ASSERT c.name IS UNIQUE; ## 3 CREATE CONSTRAINT ON (r:record) ASSERT r.name IS UNIQUE; ## 4 CREATE (ancient:Band {name: &#39;Ancient&#39;, formed: 1992}), (acturus:Band {na… ## 5 &quot;&quot; send_cypher reads a cypher file, and send it the the API. By default, the stats are returned. send_cypher(&quot;data-raw/constraints.cypher&quot;, con) 5.0.2 Sending csv to Neo4J The load_csv sends an csv from an url to the Neo4J browser. The args are : on_load : the code to execute on load con : the connexion object url : the url of the csv to send header : wether or not the csv has a header periodic_commit : the volume for PERIODIC COMMIT as : the AS argument for LOAD CSV format : the format of the result include_stats : whether or not to include the stats meta : whether or not to return the meta information # Create the constraints call_neo4j(&quot;CREATE CONSTRAINT ON (a:artist) ASSERT a.name IS UNIQUE;&quot;, con) call_neo4j(&quot;CREATE CONSTRAINT ON (al:album) ASSERT al.name IS UNIQUE;&quot;, con) # List constaints (if any) con$get_constraints() ## label type property_keys ## 1: artist UNIQUENESS name ## 2: Maintainer UNIQUENESS name ## 3: Band UNIQUENESS name ## 4: City UNIQUENESS name ## 5: record UNIQUENESS name ## 6: Package UNIQUENESS name ## 7: Author UNIQUENESS name # Create the query that will create the nodes and relationships on_load_query &lt;- &#39;MERGE (a:artist { name: csvLine.artist}) MERGE (al:album {name: csvLine.album_name}) MERGE (a) -[:has_recorded] -&gt; (al) RETURN a AS artists, al AS albums;&#39; # Send the csv load_csv(url = &quot;https://raw.githubusercontent.com/ThinkR-open/datasets/master/tracks.csv&quot;, con = con, header = TRUE, periodic_commit = 50, as = &quot;csvLine&quot;, on_load = on_load_query) ## $artists ## # A tibble: 2,367 x 1 ## name ## &lt;chr&gt; ## 1 Eminem ## 2 Eurythmics ## 3 Queen ## 4 The Police ## 5 A$AP Rocky ## 6 Tears For Fears ## 7 Foals ## 8 Bag Raiders ## 9 Bright Eyes ## 10 Bob Dylan ## # … with 2,357 more rows ## ## $albums ## # A tibble: 2,367 x 1 ## name ## &lt;chr&gt; ## 1 Curtain Call (Deluxe) ## 2 Sweet Dreams (Are Made Of This) ## 3 The Game (2011 Remaster) ## 4 Synchronicity (Remastered) ## 5 LONG.LIVE.A$AP (Deluxe Version) ## 6 Songs From The Big Chair ## 7 Holy Fire ## 8 Bag Raiders (Deluxe) ## 9 I&#39;m Wide Awake, It&#39;s Morning ## 10 Highway 61 Revisited ## # … with 2,357 more rows ## ## $stats ## # A tibble: 12 x 2 ## type value ## &lt;chr&gt; &lt;dbl&gt; ## 1 contains_updates 1 ## 2 nodes_created 1975 ## 3 nodes_deleted 0 ## 4 properties_set 1975 ## 5 relationships_created 1183 ## 6 relationship_deleted 0 ## 7 labels_added 1975 ## 8 labels_removed 0 ## 9 indexes_added 0 ## 10 indexes_removed 0 ## 11 constraints_added 0 ## 12 constraints_removed 0 ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; 5.0.3 Transform elements to cypher queries vec_to_cypher() creates a list : vec_to_cypher(iris[1, 1:3], &quot;Species&quot;) ## [1] &quot;(:`Species` {`Sepal.Length`: &#39;5.1&#39;, `Sepal.Width`: &#39;3.5&#39;, `Petal.Length`: &#39;1.4&#39;})&quot; and vec_to_cypher_with_var() creates a cypher call starting with a variable : vec_to_cypher_with_var(iris[1, 1:3], &quot;Species&quot;, a) ## [1] &quot;(a:`Species` {`Sepal.Length`: &#39;5.1&#39;, `Sepal.Width`: &#39;3.5&#39;, `Petal.Length`: &#39;1.4&#39;})&quot; This can be combined inside a cypher call: paste(&quot;MERGE&quot;, vec_to_cypher(iris[1, 1:3], &quot;Species&quot;)) ## [1] &quot;MERGE (:`Species` {`Sepal.Length`: &#39;5.1&#39;, `Sepal.Width`: &#39;3.5&#39;, `Petal.Length`: &#39;1.4&#39;})&quot; 5.1 Convert for common graph packages 5.1.1 {igraph} In order to be converted into a graph object: The nodes should be a dataframe with the first column being a series of unique ID, understood as “names” by igraph - these are the ID columns from Neo4J. Other columns are considered attributes. relationships need a start and an end, i.e. startNode and endNode in the Neo4J results. Here how to create a graph object from a {neo4r} result: G &lt;-&quot;MATCH a=(p:Person {name: &#39;Tom Hanks&#39;})-[r:ACTED_IN]-&gt;(m:Movie) RETURN a;&quot; %&gt;% call_neo4j(con, type = &quot;graph&quot;) library(dplyr) library(purrr) # Create a dataframe with col 1 being the ID, # And columns 2 being the names G$nodes &lt;- G$nodes %&gt;% unnest_nodes(what = &quot;properties&quot;) %&gt;% # We&#39;re extracting the first label of each node, but # this column can also be removed if not needed mutate(label = map_chr(label, 1)) head(G$nodes) ## # A tibble: 6 x 7 ## id label born name tagline title released ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 16149 Person 1956 Tom Ha… &lt;NA&gt; &lt;NA&gt; NA ## 2 16189 Movie NA &lt;NA&gt; Break The Codes The Da Vi… 2006 ## 3 16208 Movie NA &lt;NA&gt; Walk a mile you&#39;ll never … The Green… 1999 ## 4 16228 Movie NA &lt;NA&gt; At the edge of the world,… Cast Away 2000 ## 5 16222 Movie NA &lt;NA&gt; Houston, we have a proble… Apollo 13 1995 ## 6 16240 Movie NA &lt;NA&gt; Once in a lifetime you ge… A League … 1992 We then reorder the relationnship table: G$relationships &lt;- G$relationships %&gt;% unnest_relationships() %&gt;% select(startNode, endNode, type, everything()) head(G$relationships) ## # A tibble: 6 x 5 ## startNode endNode type id roles ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 16149 16189 ACTED_IN 23940 Dr. Robert Langdon ## 2 16149 16208 ACTED_IN 23996 Paul Edgecomb ## 3 16149 16228 ACTED_IN 24027 Chuck Noland ## 4 16149 16222 ACTED_IN 24016 Jim Lovell ## 5 16149 16240 ACTED_IN 24048 Jimmy Dugan ## 6 16149 16239 ACTED_IN 24046 Hero Boy graph_object &lt;- igraph::graph_from_data_frame( d = G$relationships, directed = TRUE, vertices = G$nodes ) plot(graph_object) This can also be used with {ggraph} : library(ggraph) ## Loading required package: ggplot2 graph_object %&gt;% ggraph() + geom_node_label(aes(label = label)) + geom_edge_link() + theme_graph() ## Using `nicely` as default layout 5.1.2 {visNetwork} {visNetwork} expects the following format : 5.1.2.1 nodes “id” : id of the node, needed in edges information “label” : label of the node “group” : group of the node. Groups can be configure with visGroups “value” : size of the node “title” : tooltip of the node 5.1.2.2 edges “from” : node id of begin of the edge “to” : node id of end of the edge “label” : label of the edge “value” : size of the node “title” : tooltip of the node (from ?visNetwork::visNetwork). visNetwork is smart enough to transform a list column into several label, so we don’t have to worry too much about this one. Here’s how to convert our {neo4r} result: G &lt;-&quot;MATCH a=(p:Person {name: &#39;Tom Hanks&#39;})-[r:ACTED_IN]-&gt;(m:Movie) RETURN a;&quot; %&gt;% call_neo4j(con, type = &quot;graph&quot;) # We&#39;ll just unnest the properties G$nodes &lt;- G$nodes %&gt;% unnest_nodes(what = &quot;properties&quot;) head(G$nodes) # Turn the relationships : G$relationships &lt;- G$relationships %&gt;% unnest_relationships() %&gt;% select(from = startNode, to = endNode, label = type) head(G$relationships) visNetwork::visNetwork(G$nodes, G$relationships) "],
["visualise.html", "Chapter 6 Visualise data 6.1 With {ggraph} :", " Chapter 6 Visualise data 6.1 With {ggraph} : Using the graph_object from previous chapter graph_object &lt;- igraph::graph_from_data_frame( d = G$relationships, directed = TRUE, vertices = G$nodes ) plot(graph_object) This can also be used with {ggraph} : library(ggraph) graph_object %&gt;% ggraph() + geom_node_label(aes(label = label)) + geom_edge_link() + theme_graph() ## Using `nicely` as default layout 6.1.1 With {visNetwork} G &lt;-&quot;MATCH a=(p:Person {name: &#39;Tom Hanks&#39;})-[r:ACTED_IN]-&gt;(m:Movie) RETURN a;&quot; %&gt;% call_neo4j(con, type = &quot;graph&quot;) # We&#39;ll just unnest the properties G$nodes &lt;- G$nodes %&gt;% unnest_nodes(what = &quot;properties&quot;) head(G$nodes) # Turn the relationships : G$relationships &lt;- G$relationships %&gt;% unnest_relationships() %&gt;% select(from = startNode, to = endNode, label = type) head(G$relationships) visNetwork::visNetwork(G$nodes, G$relationships) "],
["appendixa.html", "Chapter 7 Appendix A 7.1 Install a Neo4J server", " Chapter 7 Appendix A 7.1 Install a Neo4J server 7.1.1 On a Linux Machine 7.1.2 On a Mac Machine "]
]
