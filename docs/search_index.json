[
["index.html", "Using R &amp; Neo4J Chapter 1 About", " Using R &amp; Neo4J Colin Fay 2018-11-07 Chapter 1 About "],
["intro.html", "Chapter 2 Introduction 2.1 Installation", " Chapter 2 Introduction 2.1 Installation 2.1.1 Dev version from GitHub # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;neo4j-rstats/neo4r&quot;) "],
["connect.html", "Chapter 3 Connection 3.1 HTTP connection 3.2 Get informations about the connection :", " Chapter 3 Connection 3.1 HTTP connection You can start a new connection to your server with the neo4j_api object. You’ll need to call neo4j_api$new, with the url (with port specified if any), your user name, and your password. library(neo4r) con &lt;- neo4j_api$new( url = &quot;http://localhost:7474&quot;, user = &quot;neo4j&quot;, password = &quot;neo4j&quot; ) If you don’t want your password to be included in the script, you can use the rstudioapi::askForPassword() function, which will open a little widget asking to interactively enter your password. con &lt;- neo4j_api$new( url = &quot;http://localhost:7474&quot;, user = &quot;neo4j&quot;, password = rstudioapi::askForPassword() ) You can then check if you can access to the server by pinging it: con$ping() ## [1] 200 Which should return 200 if the connexion succeeded. 3.2 Get informations about the connection : You’ll then be able to get information about the server with: # Get Neo4J Version con$get_version() ## [1] &quot;3.4.0-rc02&quot; # List constaints (if any) con$get_constraints() ## # A tibble: 3 x 3 ## label type property_keys ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Maintainer UNIQUENESS name ## 2 Author UNIQUENESS name ## 3 Package UNIQUENESS name # Get a vector of labels (if any) con$get_labels() ## # A tibble: 9 x 1 ## labels ## &lt;chr&gt; ## 1 City ## 2 artist ## 3 Package ## 4 Maintainer ## 5 Person ## 6 record ## 7 Author ## 8 Band ## 9 album # Get a vector of relationships (if any) con$get_relationships() ## # A tibble: 4 x 1 ## labels ## &lt;chr&gt; ## 1 PLAYED_IN ## 2 IS_FROM ## 3 WAS_RECORDED ## 4 has_recorded # Get schema con$get_schema() ## # A tibble: 3 x 2 ## label property_keys ## &lt;chr&gt; &lt;chr&gt; ## 1 Author name ## 2 Package name ## 3 Maintainer name "],
["retrieve.html", "Chapter 4 Retrieve data from the API 4.1 “rows” format 4.2 Parsing results", " Chapter 4 Retrieve data from the API The API can be called either from the connection objet, or with the call_api() function. The call_api() function takes several arguments : query : the cypher query con : the connexion object type : “rows” or “graph”: wether to return the results as a list of results in tibble, or as a graph object (with $nodes and $relationships) output : the output format (R or json) include_stats : whether or not to include the stats about the call meta : wether or not to include the meta arguments of the nodes when calling with “rows” 4.1 “rows” format The user chooses wether or not to return a list of tibbles when calling the API. You get as many objects as specified in the RETURN cypher statement. library(magrittr) &#39;MATCH (r:record) -[:WAS_RECORDED] -&gt; (b:Band) where b.formed = 1991 RETURN *;&#39; %&gt;% call_api(con) ## $b ## # A tibble: 14 x 2 ## name formed ## &lt;chr&gt; &lt;int&gt; ## 1 Burzum 1991 ## 2 Burzum 1991 ## 3 Burzum 1991 ## 4 Burzum 1991 ## 5 Burzum 1991 ## 6 Burzum 1991 ## 7 Burzum 1991 ## 8 Enslaved 1991 ## 9 Enslaved 1991 ## 10 Enslaved 1991 ## 11 Enslaved 1991 ## 12 Immortal 1991 ## 13 Immortal 1991 ## 14 Immortal 1991 ## ## $r ## # A tibble: 14 x 2 ## release name ## &lt;int&gt; &lt;chr&gt; ## 1 1992 Hvis lyset tar oss ## 2 1993 Filosofem ## 3 1992 Det som engang var ## 4 1992 Aske ## 5 1991 Demo I ## 6 1992 Burzum ## 7 1991 Demo I ## 8 1993 Vikingligr Veldi ## 9 1992 Hordanes Land ## 10 1992 Yggdrasill ## 11 1991 Nema ## 12 1993 Pure Holocaust ## 13 1992 Diabolical Fullmoon Mysticism ## 14 1991 Immortal By default, results are returned as an R list of tibbles. We think this is the more “truthful” way to implement the outputs regarding Neo4J calls. For example, when you want to return two nodes types, you’ll get two results, in the form of two tibbles (what we’ve seen just before) - the result is a two elements list with each element being labelled the way it has been specified in the Cypher query. Results can also be returned in JSON: &#39;MATCH (r:record) -[:WAS_RECORDED] -&gt; (b:Band) where b.formed = 1991 RETURN *;&#39; %&gt;% call_api(con, output = &quot;json&quot;) ## [ ## [ ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Hvis lyset tar oss&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [3], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [36], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1993], ## &quot;name&quot;: [&quot;Filosofem&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [3], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [41], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Det som engang var&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [3], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [28], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Aske&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [3], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [34], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1991], ## &quot;name&quot;: [&quot;Demo I&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [3], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [25], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Burzum&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [3], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [27], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Burzum&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1991], ## &quot;name&quot;: [&quot;Demo I&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [3], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [22], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Enslaved&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1993], ## &quot;name&quot;: [&quot;Vikingligr Veldi&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [7], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [43], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Enslaved&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Hordanes Land&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [7], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [38], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Enslaved&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Yggdrasill&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [7], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [32], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Enslaved&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1991], ## &quot;name&quot;: [&quot;Nema&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [7], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [26], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Immortal&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1993], ## &quot;name&quot;: [&quot;Pure Holocaust&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [10], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [49], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Immortal&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1992], ## &quot;name&quot;: [&quot;Diabolical Fullmoon Mysticism&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [10], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [29], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## }, ## { ## &quot;row&quot;: [ ## { ## &quot;name&quot;: [&quot;Immortal&quot;], ## &quot;formed&quot;: [1991] ## }, ## { ## &quot;release&quot;: [1991], ## &quot;name&quot;: [&quot;Immortal&quot;] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [10], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## }, ## { ## &quot;id&quot;: [24], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## } ## ] ## ] If you turn the type argument to &quot;graph&quot;, you’ll get a graph result: &#39;MATCH p=()-[r:WAS_RECORDED]-&gt;() RETURN p LIMIT 5&#39; %&gt;% call_api(con, type = &quot;graph&quot;) ## $nodes ## # A tibble: 6 x 3 ## id label properties ## &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 3 &lt;chr [1]&gt; &lt;list [2]&gt; ## 2 36 &lt;chr [1]&gt; &lt;list [2]&gt; ## 3 41 &lt;chr [1]&gt; &lt;list [2]&gt; ## 4 28 &lt;chr [1]&gt; &lt;list [2]&gt; ## 5 34 &lt;chr [1]&gt; &lt;list [2]&gt; ## 6 25 &lt;chr [1]&gt; &lt;list [2]&gt; ## ## $relationships ## # A tibble: 5 x 5 ## id type startNode endNode properties ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; ## 1 26 WAS_RECORDED 36 3 &lt;list [0]&gt; ## 2 27 WAS_RECORDED 41 3 &lt;list [0]&gt; ## 3 24 WAS_RECORDED 28 3 &lt;list [0]&gt; ## 4 25 WAS_RECORDED 34 3 &lt;list [0]&gt; ## 5 22 WAS_RECORDED 25 3 &lt;list [0]&gt; ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; The result is returned as one node or relationship by row. Due to the specific data format of Neo4J, there can be more than one label and property by node and relationship. That’s why the results are returned, by design, as a list-dataframe. 4.2 Parsing results We have designed several functions to unnest the output : 4.2 unnest_nodes, that can unnest a node dataframe : res &lt;- &#39;MATCH p=()-[r:WAS_RECORDED]-&gt;() RETURN p LIMIT 5;&#39; %&gt;% call_api(con, type = &quot;graph&quot;) unnest_nodes(res$nodes) ## # A tibble: 6 x 5 ## id label name formed release ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 3 Band Burzum 1991 NA ## 2 36 record Hvis lyset tar oss NA 1992 ## 3 41 record Filosofem NA 1993 ## 4 28 record Det som engang var NA 1992 ## 5 34 record Aske NA 1992 ## 6 25 record Demo I NA 1991 Note that this function will return NA for the properties that aren’t in a node. For example here, we have no ‘formed’ information for the record nodes . On the long run, and this is not {neo4r} specific but Neo4J related, a good practice is to have a “name” propertie on each node, so this column will be full here. Also, it is possible to unnest either the properties or the labels : res$nodes %&gt;% unnest_nodes(what = &quot;properties&quot;) ## # A tibble: 6 x 5 ## id label name formed release ## &lt;chr&gt; &lt;list&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 3 &lt;chr [1]&gt; Burzum 1991 NA ## 2 36 &lt;chr [1]&gt; Hvis lyset tar oss NA 1992 ## 3 41 &lt;chr [1]&gt; Filosofem NA 1993 ## 4 28 &lt;chr [1]&gt; Det som engang var NA 1992 ## 5 34 &lt;chr [1]&gt; Aske NA 1992 ## 6 25 &lt;chr [1]&gt; Demo I NA 1991 res$nodes %&gt;% unnest_nodes(what = &quot;label&quot;) ## # A tibble: 6 x 3 ## id properties label ## &lt;chr&gt; &lt;list&gt; &lt;chr&gt; ## 1 3 &lt;list [2]&gt; Band ## 2 36 &lt;list [2]&gt; record ## 3 41 &lt;list [2]&gt; record ## 4 28 &lt;list [2]&gt; record ## 5 34 &lt;list [2]&gt; record ## 6 25 &lt;list [2]&gt; record unnest_relationships There is only one nested column in the relationship table, thus the function is quite straightforward : unnest_relationships(res$relationships) ## # A tibble: 5 x 5 ## id type startNode endNode properties ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 26 WAS_RECORDED 36 3 &lt;NA&gt; ## 2 27 WAS_RECORDED 41 3 &lt;NA&gt; ## 3 24 WAS_RECORDED 28 3 &lt;NA&gt; ## 4 25 WAS_RECORDED 34 3 &lt;NA&gt; ## 5 22 WAS_RECORDED 25 3 &lt;NA&gt; unnest_graph This function takes a graph results, and does unnest_nodes and unnest_relationships. unnest_graph(res) ## $nodes ## # A tibble: 6 x 5 ## id label name formed release ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 3 Band Burzum 1991 NA ## 2 36 record Hvis lyset tar oss NA 1992 ## 3 41 record Filosofem NA 1993 ## 4 28 record Det som engang var NA 1992 ## 5 34 record Aske NA 1992 ## 6 25 record Demo I NA 1991 ## ## $relationships ## # A tibble: 5 x 5 ## id type startNode endNode properties ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 26 WAS_RECORDED 36 3 &lt;NA&gt; ## 2 27 WAS_RECORDED 41 3 &lt;NA&gt; ## 3 24 WAS_RECORDED 28 3 &lt;NA&gt; ## 4 25 WAS_RECORDED 34 3 &lt;NA&gt; ## 5 22 WAS_RECORDED 25 3 &lt;NA&gt; ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; "],
["send.html", "Chapter 5 Sending data to the API", " Chapter 5 Sending data to the API 5.0.1 Reading and sending a cypher file : read_cypher reads a cypher file and returns a tibble of all the calls read_cypher(&quot;data-raw/create.cypher&quot;) ## # A tibble: 53 x 1 ## cypher ## &lt;chr&gt; ## 1 CREATE CONSTRAINT ON (p:Band) ASSERT p.name IS UNIQUE; ## 2 CREATE CONSTRAINT ON (p:City) ASSERT p.name IS UNIQUE; ## 3 CREATE CONSTRAINT ON (p:record) ASSERT p.name IS UNIQUE; ## 4 CREATE CONSTRAINT ON (p:artist) ASSERT p.name IS UNIQUE; ## 5 CREATE (ancient:Band {name: &#39;Ancient&#39; ,formed: 1992}), (acturus:Band {n… ## 6 CREATE CONSTRAINT ON (p:Person) ASSERT p.name IS UNIQUE; ## 7 MATCH (band:Band) WHERE band.formed &lt; 1995 RETURN *; ## 8 MATCH (b:Band) WHERE b.formed = 1990 RETURN *; ## 9 MATCH (b:Band {formed: 1990}) RETURN *; ## 10 MATCH (b:Band) WHERE b.formed &lt; 1995 RETURN *; ## # ... with 43 more rows send_cypher reads a cypher file, and send it the the API. By default, the stats are returned. send_cypher(&quot;data-raw/constraints.cypher&quot;, con) 5.0.2 Sending csv dataframe to Neo4J The load_csv sends an csv from an url to the Neo4J browser. The args are : on_load : the code to execute on load con : the connexion object url : the url of the csv to send header : wether or not the csv has a header periodic_commit : the volume for PERIODIC COMMIT as : the AS argument for LOAD CSV format : the format of the result include_stats : whether or not to include the stats meta : whether or not to return the meta information # Create the constraints call_api(&quot;CREATE CONSTRAINT ON (a:artist) ASSERT a.name IS UNIQUE;&quot;, con) call_api(&quot;CREATE CONSTRAINT ON (al:album) ASSERT al.name IS UNIQUE;&quot;, con) # List constaints (if any) con$get_constraints() ## # A tibble: 3 x 3 ## label type property_keys ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Maintainer UNIQUENESS name ## 2 Author UNIQUENESS name ## 3 Package UNIQUENESS name # Create the query that will create the nodes and relationships on_load_query &lt;- &#39;MERGE (a:artist { name: csvLine.artist}) MERGE (al:album {name: csvLine.album_name}) MERGE (a) -[:has_recorded] -&gt; (al) RETURN a AS artists, al AS albums;&#39; # Send the csv load_csv(url = &quot;https://raw.githubusercontent.com/ThinkR-open/datasets/master/tracks.csv&quot;, con = con, header = TRUE, periodic_commit = 50, as = &quot;csvLine&quot;, on_load = on_load_query) ## $artists ## # A tibble: 2,367 x 1 ## name ## &lt;chr&gt; ## 1 Eminem ## 2 Eurythmics ## 3 Queen ## 4 The Police ## 5 A$AP Rocky ## 6 Tears For Fears ## 7 Foals ## 8 Bag Raiders ## 9 Bright Eyes ## 10 Bob Dylan ## # ... with 2,357 more rows ## ## $albums ## # A tibble: 2,367 x 1 ## name ## &lt;chr&gt; ## 1 Curtain Call (Deluxe) ## 2 Sweet Dreams (Are Made Of This) ## 3 The Game (2011 Remaster) ## 4 Synchronicity (Remastered) ## 5 LONG.LIVE.A$AP (Deluxe Version) ## 6 Songs From The Big Chair ## 7 Holy Fire ## 8 Bag Raiders (Deluxe) ## 9 I&#39;m Wide Awake, It&#39;s Morning ## 10 Highway 61 Revisited ## # ... with 2,357 more rows ## ## $stats ## # A tibble: 12 x 2 ## type value ## &lt;chr&gt; &lt;dbl&gt; ## 1 contains_updates 0 ## 2 nodes_created 0 ## 3 nodes_deleted 0 ## 4 properties_set 0 ## 5 relationships_created 0 ## 6 relationship_deleted 0 ## 7 labels_added 0 ## 8 labels_removed 0 ## 9 indexes_added 0 ## 10 indexes_removed 0 ## 11 constraints_added 0 ## 12 constraints_removed 0 "],
["convert.html", "Chapter 6 Convert output", " Chapter 6 Convert output 6.0.1 {igraph} In order to be converted into a graph object, nodes need an id, and a name. By default, node name is assumed to be found in the “name” property returned by the graph, specifying any other column is allowed. The “label” column from Neo4J is renamed “group”. relationships need a start and an end, i.e. startNode and endNode in the Neo4J results. res %&gt;% convert_to(&quot;igraph&quot;) ## IGRAPH eb154db DN-- 6 5 -- ## + attr: name (v/c), group (v/c), formed (v/n), release (v/n), type ## | (e/c), id (e/c), properties (e/x) ## + edges from eb154db (vertex names): ## [1] Hvis lyset tar oss-&gt;Burzum Filosofem -&gt;Burzum ## [3] Det som engang var-&gt;Burzum Aske -&gt;Burzum ## [5] Demo I -&gt;Burzum Which means that you can : &#39;MATCH p=()-[r:WAS_RECORDED]-&gt;() RETURN p LIMIT 5;&#39; %&gt;% call_api(con, type = &quot;graph&quot;) %&gt;% convert_to(&quot;igraph&quot;) %&gt;% plot() "],
["visualise.html", "Chapter 7 Visualise data 7.1 With {ggraph} :", " Chapter 7 Visualise data 7.1 With {ggraph} : library(ggraph) &#39;MATCH p=()-[r:WAS_RECORDED]-&gt;() RETURN p LIMIT 5;&#39; %&gt;% call_api(con, type = &quot;graph&quot;) %&gt;% convert_to(&quot;igraph&quot;) %&gt;% ggraph() + geom_node_label(aes(label = name, color = group)) + geom_edge_link() + theme_graph() ## Using `nicely` as default layout 7.1.1 With {visNetwork} network &lt;- &#39;MATCH p=()-[r:WAS_RECORDED]-&gt;() RETURN p LIMIT 5;&#39; %&gt;% call_api(con, type = &quot;graph&quot;) %&gt;% convert_to(&quot;visNetwork&quot;) visNetwork::visNetwork(network$nodes, network$relationships) "],
["appendixa.html", "Chapter 8 Appendix A 8.1 Install a Neo4J server", " Chapter 8 Appendix A 8.1 Install a Neo4J server 8.1.1 On a Linux Machine 8.1.2 On a Mac Machine "]
]
