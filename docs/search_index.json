[
["index.html", "Using R &amp; Neo4J Chapter 1 About 1.1 {neo4r}", " Using R &amp; Neo4J Colin Fay 2019-06-03 Chapter 1 About This book is a user companion for using Neo4J and R together with the {neo4r} package. 1.1 {neo4r} The goal of {neo4r} is to provide a modern and flexible Neo4J driver for R. It’s modern in the sense that the results are returned as tibbles whenever possible, it relies on modern tools, and it is designed to work with pipes. Our goal is to provide a driver that can be easily integrated in a data analysis workflow, especially by providing an API working smoothly with other data analysis ({dplyr} or {purrr}) and graph packages ({igraph}, {ggraph}, {visNetwork}…). It’s flexible in the sense that it is rather unopinionated regarding the way it returns the results, by trying to stay as close as possible to the way Neo4J returns data. That way, you have the control over the way you will compute the results. At the same time, the result is not too complex, so that the “heavy lifting” of data wrangling is not left to the user. The connexion object is also an easy to control R6 method, allowing you to update and query information from the API. Sending data for this book (the movies dataset is also loaded on the server): library(neo4r) con &lt;- neo4j_api$new( url = &quot;http://localhost:7474&quot;, user = &quot;neo4j&quot;, password = &quot;password&quot; ) play_movies() %&gt;% call_neo4j(con) ## $a ## # A tibble: 10 x 2 ## born name ## &lt;int&gt; &lt;chr&gt; ## 1 1956 Tom Hanks ## 2 1956 Tom Hanks ## 3 1956 Tom Hanks ## 4 1956 Tom Hanks ## 5 1956 Tom Hanks ## 6 1956 Tom Hanks ## 7 1956 Tom Hanks ## 8 1956 Tom Hanks ## 9 1956 Tom Hanks ## 10 1956 Tom Hanks ## ## $m ## # A tibble: 10 x 3 ## tagline title released ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 In every life there comes a time when that t… That Thing You… 1996 ## 2 Once in a lifetime you get a chance to do so… A League of Th… 1992 ## 3 What if someone you never met, someone you n… Sleepless in S… 1993 ## 4 A stiff drink. A little mascara. A lot of ne… Charlie Wilson… 2007 ## 5 At the edge of the world, his journey begins. Cast Away 2000 ## 6 Walk a mile youll never forget. The Green Mile 1999 ## 7 Break The Codes The Da Vinci C… 2006 ## 8 This Holiday Season… Believe The Polar Expr… 2004 ## 9 A story of love, lava and burning desire. Joe Versus the… 1990 ## 10 Everything is connected Cloud Atlas 2012 ## ## $d ## # A tibble: 10 x 2 ## born name ## &lt;int&gt; &lt;chr&gt; ## 1 1956 Tom Hanks ## 2 1943 Penny Marshall ## 3 1941 Nora Ephron ## 4 1931 Mike Nichols ## 5 1951 Robert Zemeckis ## 6 1959 Frank Darabont ## 7 1954 Ron Howard ## 8 1951 Robert Zemeckis ## 9 1950 John Patrick Stanley ## 10 1965 Tom Tykwer ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; "],
["intro.html", "Chapter 2 Introduction 2.1 Installation", " Chapter 2 Introduction 2.1 Installation 2.1.1 Dev version from GitHub # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;neo4j-rstats/neo4r&quot;) 2.1.2 CRAN version install.packages(&quot;neo4r&quot;) "],
["connect.html", "Chapter 3 Connection 3.1 HTTP connection 3.2 Get informations about the connection :", " Chapter 3 Connection 3.1 HTTP connection You can start a new connection to your server with the neo4j_api object. You’ll need to call neo4j_api$new, with the url (with port specified if any), your user name, and your password. library(neo4r) con &lt;- neo4j_api$new( url = &quot;http://localhost:7474&quot;, user = &quot;neo4j&quot;, password = &quot;password&quot; ) If you don’t want your password to be included in the script, you can use the rstudioapi::askForPassword() function, which will open a little widget asking to interactively enter your password. con &lt;- neo4j_api$new( url = &quot;http://localhost:7474&quot;, user = &quot;neo4j&quot;, password = rstudioapi::askForPassword() ) You can then check if you can access to the server by pinging it: con$ping() ## [1] 200 Which should return 200 if the connexion succeeded. 3.2 Get informations about the connection : You’ll then be able to get information about the server with: # Get Neo4J Version con$get_version() ## [1] &quot;3.5.5&quot; # List constaints (if any) con$get_constraints() ## Null data.table (0 rows and 0 cols) # Get a table of labels (if any) con$get_labels() ## # A tibble: 2 x 1 ## labels ## &lt;chr&gt; ## 1 Person ## 2 Movie # Get a table of relationships (if any) con$get_relationships() ## # A tibble: 6 x 1 ## labels ## &lt;chr&gt; ## 1 ACTED_IN ## 2 DIRECTED ## 3 PRODUCED ## 4 WROTE ## 5 FOLLOWS ## 6 REVIEWED # Get index con$get_index() ## Null data.table (0 rows and 0 cols) "],
["retrieve.html", "Chapter 4 Retrieve data from the API 4.1 “rows” format 4.2 Parsing results", " Chapter 4 Retrieve data from the API The API can be called either from the connection objet, or with the call_neo4j() function. The call_neo4j() function takes several arguments : query : the cypher query con : the connexion object type : “rows” or “graph”: wether to return the results as a list of results in tibble, or as a graph object (with $nodes and $relationships) output : the output format (R or json) include_stats : whether or not to include the stats about the call meta : wether or not to include the meta arguments of the nodes when calling with “rows” 4.1 “rows” format The user chooses wether or not to return a list of tibbles when calling the API. You get as many objects as specified in the RETURN cypher statement. library(magrittr) &#39;MATCH (tom {name: &quot;Tom Hanks&quot;}) RETURN tom;&#39; %&gt;% call_neo4j(con) ## $tom ## # A tibble: 1 x 2 ## born name ## &lt;int&gt; &lt;chr&gt; ## 1 1956 Tom Hanks ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; By default, results are returned as an R list of tibbles. We think this is the more “truthful” way to implement the outputs regarding Neo4J calls. For example, when you want to return two nodes types, you’ll get two results, in the form of two tibbles (what we’ve seen just before) - the result is a two elements list with each element being labelled the way it has been specified in the Cypher query. Results can also be returned in JSON: &#39;MATCH (cloudAtlas {title: &quot;Cloud Atlas&quot;}) RETURN cloudAtlas;&#39; %&gt;% call_neo4j(con, output = &quot;json&quot;) ## [ ## [ ## { ## &quot;row&quot;: [ ## { ## &quot;tagline&quot;: [&quot;Everything is connected&quot;], ## &quot;title&quot;: [&quot;Cloud Atlas&quot;], ## &quot;released&quot;: [2012] ## } ## ], ## &quot;meta&quot;: [ ## { ## &quot;id&quot;: [105], ## &quot;type&quot;: [&quot;node&quot;], ## &quot;deleted&quot;: [false] ## } ## ] ## } ## ] ## ] Useful for example for writing to a file: tmp &lt;- tempfile(fileext = &quot;.json&quot;) &#39;MATCH (people:Person) RETURN people.name LIMIT 1&#39; %&gt;% call_neo4j(con, output = &quot;json&quot;) %&gt;% write(tmp) jsonlite::read_json(tmp) ## [[1]] ## [[1]][[1]] ## [[1]][[1]]$row ## [[1]][[1]]$row[[1]] ## [[1]][[1]]$row[[1]][[1]] ## [1] &quot;Keanu Reeves&quot; ## ## ## ## [[1]][[1]]$meta ## [[1]][[1]]$meta[[1]] ## named list() If you turn the type argument to &quot;graph&quot;, you’ll get a graph result: &#39;MATCH (tom:Person {name: &quot;Tom Hanks&quot;})-[act:ACTED_IN]-&gt;(tomHanksMovies) RETURN act,tom,tomHanksMovies&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) ## $nodes ## # A tibble: 13 x 3 ## id label properties ## &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 144 &lt;chr [1]&gt; &lt;list [3]&gt; ## 2 71 &lt;chr [1]&gt; &lt;list [2]&gt; ## 3 67 &lt;chr [1]&gt; &lt;list [3]&gt; ## 4 162 &lt;chr [1]&gt; &lt;list [3]&gt; ## 5 78 &lt;chr [1]&gt; &lt;list [3]&gt; ## 6 85 &lt;chr [1]&gt; &lt;list [3]&gt; ## 7 111 &lt;chr [1]&gt; &lt;list [3]&gt; ## 8 105 &lt;chr [1]&gt; &lt;list [3]&gt; ## 9 150 &lt;chr [1]&gt; &lt;list [3]&gt; ## 10 130 &lt;chr [1]&gt; &lt;list [3]&gt; ## 11 73 &lt;chr [1]&gt; &lt;list [3]&gt; ## 12 161 &lt;chr [1]&gt; &lt;list [3]&gt; ## 13 159 &lt;chr [1]&gt; &lt;list [3]&gt; ## ## $relationships ## # A tibble: 12 x 5 ## id type startNode endNode properties ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; ## 1 202 ACTED_IN 71 144 &lt;list [1]&gt; ## 2 84 ACTED_IN 71 67 &lt;list [1]&gt; ## 3 234 ACTED_IN 71 162 &lt;list [1]&gt; ## 4 98 ACTED_IN 71 78 &lt;list [1]&gt; ## 5 110 ACTED_IN 71 85 &lt;list [1]&gt; ## 6 146 ACTED_IN 71 111 &lt;list [1]&gt; ## 7 137 ACTED_IN 71 105 &lt;list [1]&gt; ## 8 213 ACTED_IN 71 150 &lt;list [1]&gt; ## 9 182 ACTED_IN 71 130 &lt;list [1]&gt; ## 10 91 ACTED_IN 71 73 &lt;list [1]&gt; ## 11 232 ACTED_IN 71 161 &lt;list [1]&gt; ## 12 228 ACTED_IN 71 159 &lt;list [1]&gt; ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; The result is returned as one node or relationship by row. Due to the specific data format of Neo4J, there can be more than one label and property by node and relationship. That’s why the results are returned, by design, as a list-dataframe. 4.2 Parsing results We have designed several functions to unnest the output : unnest_nodes(), that can unnest a node dataframe : res &lt;- &#39;MATCH (tom:Person {name:&quot;Tom Hanks&quot;})-[a:ACTED_IN]-&gt;(m)&lt;-[:ACTED_IN]-(coActors) RETURN m AS acted,coActors.name&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) unnest_nodes(res$nodes) ## # A tibble: 11 x 5 ## id value tagline title released ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 144 Movie Houston, we have a problem. Apollo 13 1995 ## 2 67 Movie At odds in life... in love on-line. Youve Got M… 1998 ## 3 162 Movie Once in a lifetime you get a chance… A League of… 1992 ## 4 78 Movie A story of love, lava and burning d… Joe Versus … 1990 ## 5 85 Movie In every life there comes a time wh… That Thing … 1996 ## 6 111 Movie Break The Codes The Da Vinc… 2006 ## 7 105 Movie Everything is connected Cloud Atlas 2012 ## 8 150 Movie At the edge of the world, his journ… Cast Away 2000 ## 9 130 Movie Walk a mile youll never forget. The Green M… 1999 ## 10 73 Movie What if someone you never met, some… Sleepless i… 1993 ## 11 159 Movie A stiff drink. A little mascara. A … Charlie Wil… 2007 Note that this function will return NA for the properties that aren’t in a node. For example here, we have no ‘formed’ information for the record nodes . On the long run, and this is not {neo4r} specific but Neo4J related, a good practice is to have a “name” propertie on each node, so this column will be full here. Also, it is possible to unnest either the properties or the labels : res %&gt;% extract_nodes() %&gt;% unnest_nodes(what = &quot;properties&quot;) ## # A tibble: 11 x 5 ## id label tagline title released ## &lt;chr&gt; &lt;list&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 144 &lt;chr [… Houston, we have a problem. Apollo 13 1995 ## 2 67 &lt;chr [… At odds in life... in love on-lin… Youve Got M… 1998 ## 3 162 &lt;chr [… Once in a lifetime you get a chan… A League of… 1992 ## 4 78 &lt;chr [… A story of love, lava and burning… Joe Versus … 1990 ## 5 85 &lt;chr [… In every life there comes a time … That Thing … 1996 ## 6 111 &lt;chr [… Break The Codes The Da Vinc… 2006 ## 7 105 &lt;chr [… Everything is connected Cloud Atlas 2012 ## 8 150 &lt;chr [… At the edge of the world, his jou… Cast Away 2000 ## 9 130 &lt;chr [… Walk a mile youll never forget. The Green M… 1999 ## 10 73 &lt;chr [… What if someone you never met, so… Sleepless i… 1993 ## 11 159 &lt;chr [… A stiff drink. A little mascara. … Charlie Wil… 2007 res %&gt;% extract_nodes() %&gt;% unnest_nodes(what = &quot;label&quot;) ## # A tibble: 11 x 3 ## id properties value ## &lt;chr&gt; &lt;list&gt; &lt;chr&gt; ## 1 144 &lt;list [3]&gt; Movie ## 2 67 &lt;list [3]&gt; Movie ## 3 162 &lt;list [3]&gt; Movie ## 4 78 &lt;list [3]&gt; Movie ## 5 85 &lt;list [3]&gt; Movie ## 6 111 &lt;list [3]&gt; Movie ## 7 105 &lt;list [3]&gt; Movie ## 8 150 &lt;list [3]&gt; Movie ## 9 130 &lt;list [3]&gt; Movie ## 10 73 &lt;list [3]&gt; Movie ## 11 159 &lt;list [3]&gt; Movie unnest_relationships() There is only one nested column in the relationship table, thus the function is quite straightforward : &#39;MATCH (people:Person)-[relatedTo]-(:Movie {title: &quot;Cloud Atlas&quot;}) RETURN people.name, Type(relatedTo), relatedTo&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) %&gt;% extract_relationships() %&gt;% unnest_relationships() ## # A tibble: 23 x 8 ## id type startNode endNode roles value summary rating ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; &lt;lgl&gt; &lt;chr&gt; &lt;int&gt; ## 1 137 ACTED_IN 71 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 2 137 ACTED_IN 71 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 3 137 ACTED_IN 71 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 4 137 ACTED_IN 71 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 5 140 ACTED_IN 107 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 6 140 ACTED_IN 107 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 7 140 ACTED_IN 107 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 8 144 WROTE 109 105 &lt;NULL&gt; NA &lt;NA&gt; NA ## 9 141 DIRECTED 108 105 &lt;NULL&gt; NA &lt;NA&gt; NA ## 10 143 DIRECTED 6 105 &lt;NULL&gt; NA &lt;NA&gt; NA ## # … with 13 more rows unnest_graph() This function takes a graph results, and does unnest_nodes and unnest_relationships. &#39;MATCH (people:Person)-[relatedTo]-(:Movie {title: &quot;Cloud Atlas&quot;}) RETURN people.name, Type(relatedTo), relatedTo&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) %&gt;% unnest_graph() ## $nodes ## # A tibble: 11 x 7 ## id value born name tagline title released ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 71 Person 1956 Tom Hanks &lt;NA&gt; &lt;NA&gt; NA ## 2 105 Movie NA &lt;NA&gt; Everything is con… Cloud At… 2012 ## 3 107 Person 1949 Jim Broadbent &lt;NA&gt; &lt;NA&gt; NA ## 4 109 Person 1969 David Mitche… &lt;NA&gt; &lt;NA&gt; NA ## 5 108 Person 1965 Tom Tykwer &lt;NA&gt; &lt;NA&gt; NA ## 6 6 Person 1965 Lana Wachows… &lt;NA&gt; &lt;NA&gt; NA ## 7 110 Person 1961 Stefan Arndt &lt;NA&gt; &lt;NA&gt; NA ## 8 169 Person NA Jessica Thom… &lt;NA&gt; &lt;NA&gt; NA ## 9 106 Person 1966 Halle Berry &lt;NA&gt; &lt;NA&gt; NA ## 10 4 Person 1960 Hugo Weaving &lt;NA&gt; &lt;NA&gt; NA ## 11 5 Person 1967 Lilly Wachow… &lt;NA&gt; &lt;NA&gt; NA ## ## $relationships ## # A tibble: 23 x 8 ## id type startNode endNode roles value summary rating ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; &lt;lgl&gt; &lt;chr&gt; &lt;int&gt; ## 1 137 ACTED_IN 71 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 2 137 ACTED_IN 71 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 3 137 ACTED_IN 71 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 4 137 ACTED_IN 71 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 5 140 ACTED_IN 107 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 6 140 ACTED_IN 107 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 7 140 ACTED_IN 107 105 &lt;chr [1]&gt; NA &lt;NA&gt; NA ## 8 144 WROTE 109 105 &lt;NULL&gt; NA &lt;NA&gt; NA ## 9 141 DIRECTED 108 105 &lt;NULL&gt; NA &lt;NA&gt; NA ## 10 143 DIRECTED 6 105 &lt;NULL&gt; NA &lt;NA&gt; NA ## # … with 13 more rows ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; 4.2.1 Extraction There are two convenient functions to extract nodes and relationships: &#39;MATCH (bacon:Person {name:&quot;Kevin Bacon&quot;})-[*1..4]-(hollywood) RETURN DISTINCT hollywood&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) %&gt;% extract_nodes() ## # A tibble: 135 x 3 ## id label properties ## &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 72 &lt;chr [1]&gt; &lt;list [2]&gt; ## 2 68 &lt;chr [1]&gt; &lt;list [2]&gt; ## 3 54 &lt;chr [1]&gt; &lt;list [2]&gt; ## 4 34 &lt;chr [1]&gt; &lt;list [2]&gt; ## 5 70 &lt;chr [1]&gt; &lt;list [2]&gt; ## 6 69 &lt;chr [1]&gt; &lt;list [2]&gt; ## 7 67 &lt;chr [1]&gt; &lt;list [3]&gt; ## 8 163 &lt;chr [1]&gt; &lt;list [2]&gt; ## 9 166 &lt;chr [1]&gt; &lt;list [2]&gt; ## 10 77 &lt;chr [1]&gt; &lt;list [2]&gt; ## # … with 125 more rows &#39;MATCH p=shortestPath( (bacon:Person {name:&quot;Kevin Bacon&quot;})-[*]-(meg:Person {name:&quot;Meg Ryan&quot;}) ) RETURN p&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) %&gt;% extract_relationships() ## # A tibble: 4 x 5 ## id type startNode endNode properties ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; ## 1 202 ACTED_IN 71 144 &lt;list [1]&gt; ## 2 203 ACTED_IN 19 144 &lt;list [1]&gt; ## 3 91 ACTED_IN 71 73 &lt;list [1]&gt; ## 4 92 ACTED_IN 34 73 &lt;list [1]&gt; "],
["send.html", "Chapter 5 Sending data to the API 5.1 Reading and sending a cypher file : 5.2 Sending csv to Neo4J 5.3 Transform elements to cypher queries", " Chapter 5 Sending data to the API 5.1 Reading and sending a cypher file : read_cypher reads a cypher file and returns a tibble of all the calls read_cypher(&quot;data-raw/create.cypher&quot;) ## # A tibble: 5 x 1 ## cypher ## &lt;chr&gt; ## 1 CREATE CONSTRAINT ON (b:Band) ASSERT b.name IS UNIQUE; ## 2 CREATE CONSTRAINT ON (c:City) ASSERT c.name IS UNIQUE; ## 3 CREATE CONSTRAINT ON (r:record) ASSERT r.name IS UNIQUE; ## 4 CREATE (ancient:Band {name: &#39;Ancient&#39;, formed: 1992}), (acturus:Band {… ## 5 &quot;&quot; send_cypher reads a cypher file, and send it the the API. By default, the stats are returned. send_cypher(&quot;data-raw/constraints.cypher&quot;, con) 5.2 Sending csv to Neo4J The load_csv sends an csv from an url to the Neo4J browser. The args are : on_load : the code to execute on load con : the connexion object url : the url of the csv to send header : wether or not the csv has a header periodic_commit : the volume for PERIODIC COMMIT as : the AS argument for LOAD CSV format : the format of the result include_stats : whether or not to include the stats meta : whether or not to return the meta information on_load_query &lt;- &#39;CREATE (n:Product) SET n = row, n.unitPrice = toFloat(row.unitPrice), n.unitsInStock = toInteger(row.unitsInStock), n.unitsOnOrder = toInteger(row.unitsOnOrder), n.reorderLevel = toInteger(row.reorderLevel), n.discontinued = (row.discontinued &lt;&gt; &quot;0&quot;);&#39; # Send the csv load_csv(url = &quot;http://data.neo4j.com/northwind/products.csv&quot;, con = con, header = TRUE, periodic_commit = 50, as = &quot;row&quot;, on_load = on_load_query) ## No data returned. ## # A tibble: 12 x 2 ## type value ## &lt;chr&gt; &lt;dbl&gt; ## 1 contains_updates 1 ## 2 nodes_created 77 ## 3 nodes_deleted 0 ## 4 properties_set 1155 ## 5 relationships_created 0 ## 6 relationship_deleted 0 ## 7 labels_added 77 ## 8 labels_removed 0 ## 9 indexes_added 0 ## 10 indexes_removed 0 ## 11 constraints_added 0 ## 12 constraints_removed 0 5.3 Transform elements to cypher queries vec_to_cypher() creates a list : vec_to_cypher(iris[1, 1:3], &quot;Species&quot;) ## [1] &quot;(:`Species` {`Sepal.Length`: &#39;5.1&#39;, `Sepal.Width`: &#39;3.5&#39;, `Petal.Length`: &#39;1.4&#39;})&quot; and vec_to_cypher_with_var() creates a cypher call starting with a variable : vec_to_cypher_with_var(iris[1, 1:3], &quot;Species&quot;, a) ## [1] &quot;(a:`Species` {`Sepal.Length`: &#39;5.1&#39;, `Sepal.Width`: &#39;3.5&#39;, `Petal.Length`: &#39;1.4&#39;})&quot; This can be combined inside a cypher call: paste(&quot;MERGE&quot;, vec_to_cypher(iris[1, 1:3], &quot;Species&quot;)) ## [1] &quot;MERGE (:`Species` {`Sepal.Length`: &#39;5.1&#39;, `Sepal.Width`: &#39;3.5&#39;, `Petal.Length`: &#39;1.4&#39;})&quot; "],
["convert-for-common-graph-packages.html", "Chapter 6 Convert for common graph packages 6.1 {igraph} 6.2 {visNetwork}", " Chapter 6 Convert for common graph packages 6.1 {igraph} In order to be converted into a graph object: The nodes should be a dataframe with the first column being a series of unique ID, understood as “names” by igraph - these are the ID columns from Neo4J. Other columns are considered attributes. relationships need a start and an end, i.e. startNode and endNode in the Neo4J results. Here how to create a graph object from a {neo4r} result: G &lt;-&quot;MATCH a=(p:Person {name: &#39;Tom Hanks&#39;})-[r:ACTED_IN]-&gt;(m:Movie) RETURN a;&quot; %&gt;% call_neo4j(con, type = &quot;graph&quot;) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(purrr) ## ## Attaching package: &#39;purrr&#39; ## The following object is masked from &#39;package:magrittr&#39;: ## ## set_names # Create a dataframe with col 1 being the ID, # And columns 2 being the names G$nodes &lt;- G$nodes %&gt;% unnest_nodes(what = &quot;properties&quot;) %&gt;% # We&#39;re extracting the first label of each node, but # this column can also be removed if not needed mutate(label = map_chr(label, 1)) head(G$nodes) ## # A tibble: 6 x 7 ## id label tagline title released born name ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 144 Movie Houston, we have a proble… Apollo 13 1995 NA &lt;NA&gt; ## 2 71 Person &lt;NA&gt; &lt;NA&gt; NA 1956 Tom H… ## 3 67 Movie At odds in life... in lov… Youve Go… 1998 NA &lt;NA&gt; ## 4 162 Movie Once in a lifetime you ge… A League… 1992 NA &lt;NA&gt; ## 5 78 Movie A story of love, lava and… Joe Vers… 1990 NA &lt;NA&gt; ## 6 85 Movie In every life there comes… That Thi… 1996 NA &lt;NA&gt; We then reorder the relationnship table: G$relationships &lt;- G$relationships %&gt;% unnest_relationships() %&gt;% select(startNode, endNode, type, everything()) head(G$relationships) ## # A tibble: 6 x 5 ## startNode endNode type id roles ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;list&gt; ## 1 71 144 ACTED_IN 202 &lt;chr [1]&gt; ## 2 71 67 ACTED_IN 84 &lt;chr [1]&gt; ## 3 71 162 ACTED_IN 234 &lt;chr [1]&gt; ## 4 71 78 ACTED_IN 98 &lt;chr [1]&gt; ## 5 71 85 ACTED_IN 110 &lt;chr [1]&gt; ## 6 71 111 ACTED_IN 146 &lt;chr [1]&gt; graph_object &lt;- igraph::graph_from_data_frame( d = G$relationships, directed = TRUE, vertices = G$nodes ) plot(graph_object) This can also be used with {ggraph} : library(ggraph) ## Loading required package: ggplot2 graph_object %&gt;% ggraph() + geom_node_label(aes(label = label)) + geom_edge_link() + theme_graph() ## Using `nicely` as default layout 6.2 {visNetwork} {visNetwork} expects the following format : 6.2.1 nodes “id” : id of the node, needed in edges information “label” : label of the node “group” : group of the node. Groups can be configure with visGroups “value” : size of the node “title” : tooltip of the node 6.2.2 edges “from” : node id of begin of the edge “to” : node id of end of the edge “label” : label of the edge “value” : size of the node “title” : tooltip of the node (from ?visNetwork::visNetwork). visNetwork is smart enough to transform a list column into several label, so we don’t have to worry too much about this one. Here’s how to convert our {neo4r} result: G &lt;-&quot;MATCH a=(p:Person {name: &#39;Tom Hanks&#39;})-[r:ACTED_IN]-&gt;(m:Movie) RETURN a;&quot; %&gt;% call_neo4j(con, type = &quot;graph&quot;) # We&#39;ll just unnest the properties G$nodes &lt;- G$nodes %&gt;% unnest_nodes(what = &quot;properties&quot;) head(G$nodes) # Turn the relationships : G$relationships &lt;- G$relationships %&gt;% unnest_relationships() %&gt;% select(from = startNode, to = endNode, label = type) head(G$relationships) visNetwork::visNetwork(G$nodes, G$relationships) "],
["visualise.html", "Chapter 7 Visualise data 7.1 With {ggraph} : 7.2 With {visNetwork}", " Chapter 7 Visualise data 7.1 With {ggraph} : Using the graph_object from previous chapter graph_object &lt;- igraph::graph_from_data_frame( d = G$relationships, directed = TRUE, vertices = G$nodes ) plot(graph_object) This can also be used with {ggraph} : library(ggraph) graph_object %&gt;% ggraph() + geom_node_label(aes(label = label)) + geom_edge_link() + theme_graph() ## Using `nicely` as default layout 7.2 With {visNetwork} G &lt;-&quot;MATCH a=(p:Person {name: &#39;Tom Hanks&#39;})-[r:ACTED_IN]-&gt;(m:Movie) RETURN a;&quot; %&gt;% call_neo4j(con, type = &quot;graph&quot;) # We&#39;ll just unnest the properties G$nodes &lt;- G$nodes %&gt;% unnest_nodes(what = &quot;properties&quot;) head(G$nodes) # Turn the relationships : G$relationships &lt;- G$relationships %&gt;% unnest_relationships() %&gt;% select(from = startNode, to = endNode, label = type) head(G$relationships) visNetwork::visNetwork(G$nodes, G$relationships) "],
["movie.html", "Chapter 8 The Movie Dataset 8.1 Querying data 8.2 Basic data manipulation", " Chapter 8 The Movie Dataset Neo4J comes with an example dataset called movies, which you can use with: play_movies() %&gt;% call_neo4j(con) 8.1 Querying data Returning data as data.frames: &#39;MATCH (tom {name: &quot;Tom Hanks&quot;}) RETURN tom&#39; %&gt;% call_neo4j(con) ## $tom ## # A tibble: 1 x 2 ## born name ## &lt;int&gt; &lt;chr&gt; ## 1 1956 Tom Hanks ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; &#39;MATCH (cloudAtlas {title: &quot;Cloud Atlas&quot;}) RETURN cloudAtlas&#39; %&gt;% call_neo4j(con) ## $cloudAtlas ## # A tibble: 1 x 3 ## tagline title released ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Everything is connected Cloud Atlas 2012 ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; &#39;MATCH (people:Person) RETURN people.name LIMIT 10&#39; %&gt;% call_neo4j(con) ## $people.name ## # A tibble: 10 x 1 ## value ## &lt;chr&gt; ## 1 Keanu Reeves ## 2 Carrie-Anne Moss ## 3 Laurence Fishburne ## 4 Hugo Weaving ## 5 Lilly Wachowski ## 6 Lana Wachowski ## 7 Joel Silver ## 8 Emil Eifrem ## 9 Charlize Theron ## 10 Al Pacino ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; &#39;MATCH (nineties:Movie) WHERE nineties.released &gt;= 1990 AND nineties.released &lt; 2000 RETURN nineties.title&#39; %&gt;% call_neo4j(con) ## $nineties.title ## # A tibble: 20 x 1 ## value ## &lt;chr&gt; ## 1 The Matrix ## 2 The Devils Advocate ## 3 A Few Good Men ## 4 As Good as It Gets ## 5 What Dreams May Come ## 6 Snow Falling on Cedars ## 7 Youve Got Mail ## 8 Sleepless in Seattle ## 9 Joe Versus the Volcano ## 10 When Harry Met Sally ## 11 That Thing You Do ## 12 The Birdcage ## 13 Unforgiven ## 14 Johnny Mnemonic ## 15 The Green Mile ## 16 Hoffa ## 17 Apollo 13 ## 18 Twister ## 19 Bicentennial Man ## 20 A League of Their Own ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; &#39;MATCH (bacon:Person {name:&quot;Kevin Bacon&quot;})-[*1..4]-(hollywood) RETURN DISTINCT hollywood&#39; %&gt;% call_neo4j(con) ## $hollywood ## # A tibble: 135 x 5 ## born name tagline title released ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1941 Nora Ephron &lt;NA&gt; &lt;NA&gt; NA ## 2 1968 Parker Posey &lt;NA&gt; &lt;NA&gt; NA ## 3 1963 Greg Kinnear &lt;NA&gt; &lt;NA&gt; NA ## 4 1961 Meg Ryan &lt;NA&gt; &lt;NA&gt; NA ## 5 1967 Steve Zahn &lt;NA&gt; &lt;NA&gt; NA ## 6 1973 Dave Chappel… &lt;NA&gt; &lt;NA&gt; NA ## 7 NA &lt;NA&gt; At odds in life... in love … Youve Got M… 1998 ## 8 1954 Madonna &lt;NA&gt; &lt;NA&gt; NA ## 9 1943 Penny Marsha… &lt;NA&gt; &lt;NA&gt; NA ## 10 1962 Rosie ODonne… &lt;NA&gt; &lt;NA&gt; NA ## # … with 125 more rows ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; Returning data as graphs: &#39;MATCH (tom:Person {name: &quot;Tom Hanks&quot;})-[:ACTED_IN]-&gt;(tomHanksMovies) RETURN tom,tomHanksMovies&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) ## $nodes ## # A tibble: 13 x 3 ## id label properties ## &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 144 &lt;chr [1]&gt; &lt;list [3]&gt; ## 2 71 &lt;chr [1]&gt; &lt;list [2]&gt; ## 3 67 &lt;chr [1]&gt; &lt;list [3]&gt; ## 4 162 &lt;chr [1]&gt; &lt;list [3]&gt; ## 5 78 &lt;chr [1]&gt; &lt;list [3]&gt; ## 6 85 &lt;chr [1]&gt; &lt;list [3]&gt; ## 7 111 &lt;chr [1]&gt; &lt;list [3]&gt; ## 8 105 &lt;chr [1]&gt; &lt;list [3]&gt; ## 9 150 &lt;chr [1]&gt; &lt;list [3]&gt; ## 10 130 &lt;chr [1]&gt; &lt;list [3]&gt; ## 11 73 &lt;chr [1]&gt; &lt;list [3]&gt; ## 12 161 &lt;chr [1]&gt; &lt;list [3]&gt; ## 13 159 &lt;chr [1]&gt; &lt;list [3]&gt; ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; &#39;MATCH (cloudAtlas {title: &quot;Cloud Atlas&quot;})&lt;-[:DIRECTED]-(directors) RETURN directors&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) %&gt;% extract_nodes() ## # A tibble: 3 x 3 ## id label properties ## &lt;chr&gt; &lt;list&gt; &lt;list&gt; ## 1 108 &lt;chr [1]&gt; &lt;list [2]&gt; ## 2 6 &lt;chr [1]&gt; &lt;list [2]&gt; ## 3 5 &lt;chr [1]&gt; &lt;list [2]&gt; &#39;MATCH (tom:Person {name:&quot;Tom Hanks&quot;})-[:ACTED_IN]-&gt;(m)&lt;-[:ACTED_IN]-(coActors) RETURN coActors&#39; %&gt;% call_neo4j(con, type = &quot;graph&quot;) %&gt;% unnest_graph() ## $nodes ## # A tibble: 34 x 4 ## id value born name ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 145 Person 1950 Ed Harris ## 2 134 Person 1955 Gary Sinise ## 3 19 Person 1958 Kevin Bacon ## 4 146 Person 1955 Bill Paxton ## 5 68 Person 1968 Parker Posey ## 6 54 Person 1963 Greg Kinnear ## 7 34 Person 1961 Meg Ryan ## 8 70 Person 1967 Steve Zahn ## 9 69 Person 1973 Dave Chappelle ## 10 163 Person 1954 Madonna ## # … with 24 more rows ## ## attr(,&quot;class&quot;) ## [1] &quot;neo&quot; &quot;list&quot; 8.2 Basic data manipulation library(tidyverse) ## ── Attaching packages ──────────────────────────────── tidyverse 1.2.1 ── ## ✔ tibble 2.1.1 ✔ readr 1.3.1 ## ✔ tidyr 0.8.3 ✔ stringr 1.4.0 ## ✔ tibble 2.1.1 ✔ forcats 0.3.0 ## ── Conflicts ─────────────────────────────────── tidyverse_conflicts() ── ## ✖ tidyr::extract() masks magrittr::extract() ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ✖ purrr::set_names() masks magrittr::set_names() res &lt;- &#39;MATCH (per)-[act:ACTED_IN]-&gt;(mov) RETURN per, mov&#39; %&gt;% call_neo4j(con) df &lt;- bind_cols( purrr::pluck(res, &quot;per&quot;), purrr::pluck(res, &quot;mov&quot;) ) df %&gt;% count(name, sort = TRUE) %&gt;% top_n(10) ## Selecting by n ## # A tibble: 15 x 2 ## name n ## &lt;chr&gt; &lt;int&gt; ## 1 Tom Hanks 12 ## 2 Keanu Reeves 7 ## 3 Hugo Weaving 5 ## 4 Jack Nicholson 5 ## 5 Meg Ryan 5 ## 6 Cuba Gooding Jr. 4 ## 7 Ben Miles 3 ## 8 Bill Paxton 3 ## 9 Carrie-Anne Moss 3 ## 10 Gene Hackman 3 ## 11 Helen Hunt 3 ## 12 Kevin Bacon 3 ## 13 Laurence Fishburne 3 ## 14 Robin Williams 3 ## 15 Tom Cruise 3 df %&gt;% distinct(title, released) %&gt;% count(released) %&gt;% ggplot(aes(released, n)) + geom_col(fill = viridis::viridis(1)) + labs( title = &quot;Movies by year in the &#39;movies&#39; dataset&quot; ) + theme_minimal() "],
["appendixa.html", "Chapter 9 Appendix A 9.1 Install a Neo4J server", " Chapter 9 Appendix A 9.1 Install a Neo4J server 9.1.1 On a Linux Machine 9.1.2 On a Mac Machine "]
]
