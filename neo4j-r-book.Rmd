--- 
title: "Using R & Neo4J"
author: "Colin Fay"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "A Guide About Using Neo4J and R"
---

# About 

This book is a user companion for using Neo4J and R together with the `{neo4r}` package.

```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')

library(neo4r)
con <- neo4j_api$new(
  url = "http://localhost:7474",
  user = "neo4j", 
  password = "pouetpouet"
  )
call_api("MATCH (n) DETACH DELETE n", con)
send_cypher("data-raw/create.cypher", con)
```


<!--chapter:end:index.rmd-->

# Introduction {#intro}

## Installation 

### Dev version from GitHub

```{r eval = FALSE}
# install.packages("remotes")
remotes::install_github("neo4j-rstats/neo4r")
```


<!--chapter:end:intro.Rmd-->

# Connection {#connect}

## HTTP connection 

You can start a new connection to your server with the `neo4j_api` object. 

You'll need to call `neo4j_api$new`, with the url (with port specified if any), your user name, and your  password. 

```{r}
library(neo4r)
con <- neo4j_api$new(
  url = "http://localhost:7474",
  user = "neo4j", 
  password = "pouetpouet"
  )
```

If you don't want your password to be included in the script, you can use the `rstudioapi::askForPassword()` function, which will open a little widget asking to interactively enter your password. 

```{r eval = FALSE}
con <- neo4j_api$new(
  url = "http://localhost:7474",
  user = "neo4j", 
  password = rstudioapi::askForPassword()
  )
```

You can then check if you can access to the server by pinging it:

```{r}
con$ping()
```

Which should return 200 if the connexion succeeded. 

## Get informations about the connection :

You'll then be able to get information about the server with: 

```{r}
# Get Neo4J Version
con$get_version()
# List constaints (if any)
con$get_constraints()
# Get a vector of labels (if any)
con$get_labels()
# Get a vector of relationships (if any)
con$get_relationships()
# Get schema 
con$get_schema()
```


<!--chapter:end:connection.Rmd-->

# Retrieve data from the API {#retrieve}

The API can be called either from the connection objet, or with the `call_api()` function. 

The `call_api()` function takes several arguments : 

+ `query` : the cypher query
+ `con` : the connexion object 
+ `type` : "rows" or "graph": wether to return the results as a list of results in tibble, or as a graph object (with `$nodes` and `$relationships`)
+ `output` : the output format (R or json) 
+ `include_stats` : whether or not to include the stats about the call 
+ `meta` : wether or not to include the meta arguments of the nodes when calling with "rows"

## "rows" format

The user chooses wether or not to return a list of tibbles when calling the API. You get as many objects as specified in the RETURN cypher statement. 

```{r}
library(magrittr)

'MATCH (r:record) -[:WAS_RECORDED] -> (b:Band) where b.formed = 1991 RETURN *;' %>%
  call_api(con)
```

By default, results are returned as an R list of tibbles. We think this is the more "truthful" way to implement the outputs regarding Neo4J calls. 

For example, when you want to return two nodes types, you'll get two results, in the form of two tibbles (what we've seen just before) - the result is a two elements list with each element being labelled the way it has been specified in the Cypher query. 

Results can also be returned in JSON:

```{r}
'MATCH (r:record) -[:WAS_RECORDED] -> (b:Band) where b.formed = 1991 RETURN *;' %>%
  call_api(con, output = "json")
```

If you turn the `type` argument to `"graph"`, you'll get a graph result: 

```{r}
'MATCH p=()-[r:WAS_RECORDED]->() RETURN p LIMIT 5' %>%
  call_api(con, type = "graph")
```

The result is returned as one node or relationship by row. 

Due to the specific data format of Neo4J, there can be more than one label and property by node and relationship. That's why the results are returned, by design, as a list-dataframe. 

## Parsing results 

We have designed several functions to unnest the output : 

+ `unnest_nodes()`, that can unnest a node dataframe : 

```{r}
res <- 'MATCH p=()-[r:WAS_RECORDED]->() RETURN p LIMIT 5;' %>%
  call_api(con, type = "graph")
unnest_nodes(res$nodes)
```

Note that this function will return `NA` for the properties that aren't in a node. For example here, we have no 'formed' information for the record nodes .

On the long run, and this is not {neo4r} specific but Neo4J related, a good practice is to have a "name" propertie on each node, so this column will be full here.

Also, it is possible to unnest either the properties or the labels : 

```{r}
res$nodes %>%
  unnest_nodes(what = "properties")
```

```{r}
res$nodes %>%
  unnest_nodes(what = "label")
```

+ `unnest_relationships()`

There is only one nested column in the relationship table, thus the function is quite straightforward : 

```{r}
unnest_relationships(res$relationships)
```

+ `unnest_graph()`

This function takes a graph results, and does `unnest_nodes` and `unnest_relationships`. 

```{r}
unnest_graph(res)
```

### Extraction 

There are two convenient functions to extract nodes and relationships: 

```{r}
'MATCH p=()-[r:WAS_RECORDED]->() RETURN p LIMIT 5;' %>%
  call_api(con, type = "graph") %>% 
  extract_nodes()
```


<!--chapter:end:get_data.Rmd-->

# Sending data to the API {#send}

### Reading and sending a cypher file :

+ `read_cypher` reads a cypher file and returns a tibble of all the calls

```{r}
read_cypher("data-raw/create.cypher")
```

+ `send_cypher` reads a cypher file, and send it the the API. By default, the stats are returned. 

```{r eval = FALSE}
send_cypher("data-raw/constraints.cypher", con)
```


### Sending csv to Neo4J

The `load_csv` sends an csv from an url to the Neo4J browser. 

The args are : 

+ `on_load` : the code to execute on load 
+ `con` : the connexion object 
+ `url` : the url of the csv to send
+ `header` : wether or not the csv has a header
+ `periodic_commit` : the volume for PERIODIC COMMIT
+ `as` : the AS argument for LOAD CSV
+ `format` : the format of the result 
+ `include_stats` : whether or not to include the stats 
+ `meta` : whether or not to return the meta information

```{r eval = FALSE}
# Create the constraints
call_api("CREATE CONSTRAINT ON (a:artist) ASSERT a.name IS UNIQUE;", con)
call_api("CREATE CONSTRAINT ON (al:album) ASSERT al.name IS UNIQUE;", con)
```

```{r}
# List constaints (if any)
con$get_constraints()
# Create the query that will create the nodes and relationships
on_load_query <- 'MERGE (a:artist { name: csvLine.artist})
MERGE (al:album {name: csvLine.album_name})
MERGE (a) -[:has_recorded] -> (al)  
RETURN a AS artists, al AS albums;'
# Send the csv 
load_csv(url = "https://raw.githubusercontent.com/ThinkR-open/datasets/master/tracks.csv", 
         con = con, header = TRUE, periodic_commit = 50, 
         as = "csvLine", on_load = on_load_query)
```

### Transform elements to cypher queries

+ `vec_to_cypher()` creates a list : 

```{r}
vec_to_cypher(iris[1, 1:3], "Species")
```

+ and `vec_to_cypher_with_var()` creates a cypher call starting with a variable : 

```{r}
vec_to_cypher_with_var(iris[1, 1:3], "Species", a)
```

This can be combined inside a cypher call: 

```{r}
paste("MERGE", vec_to_cypher(iris[1, 1:3], "Species"))
```


<!--chapter:end:send_data.Rmd-->

# Convert output {#convert}

### {igraph}

In order to be converted into a graph object:

+ nodes need an id, and a name. By default, node name is assumed to be found in the "name" property returned by the graph, specifying any other column is allowed. The "label" column from Neo4J is renamed "group".

+ relationships need a start and an end, *i.e.* startNode and endNode in the Neo4J results. 

```{r}
res %>%
  convert_to("igraph")
```

Which means that you can : 

```{r}
'MATCH p=()-[r:WAS_RECORDED]->() RETURN p LIMIT 5;' %>%
  call_api(con, type = "graph") %>% 
  convert_to("igraph") %>%
  plot()
```

<!--chapter:end:convert.Rmd-->

# Visualise data {#visualise}

## With `{ggraph}` :

```{r}
library(ggraph)
'MATCH p=()-[r:WAS_RECORDED]->() RETURN p LIMIT 5;' %>%
  call_api(con, type = "graph") %>% 
  convert_to("igraph") %>%
  ggraph() + 
  geom_node_label(aes(label = name, color = group)) +
  geom_edge_link() + 
  theme_graph()
```

### With `{visNetwork}`

```{r}
network <- 'MATCH p=()-[r:WAS_RECORDED]->() RETURN p LIMIT 5;' %>%
  call_api(con, type = "graph") %>% 
  convert_to("visNetwork")
visNetwork::visNetwork(network$nodes, network$relationships)
```

<!--chapter:end:visualise.Rmd-->

# Appendix A {#appendixa}

## Install a Neo4J server 

### On a Linux Machine


### On a Mac Machine


<!--chapter:end:appendix-A.Rmd-->

